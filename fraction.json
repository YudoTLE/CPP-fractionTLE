"Fraction": {
		"prefix": ["data_structure_fraction"],
		"body": [
			"$1#pragma region Fraction",
			"",
			"#ifndef _FRACTION",
			"#define _FRACTION 1",
			"",
			"template <typename _Tp>",
			"class fraction",
			"{",
			"public:",
			"\t_Tp numerator;",
			"\t_Tp denominator;",
			"",
			"private:",
			"\tvoid normalize()",
			"\t{",
			"\t\t_Tp GCD = gcd(numerator, denominator);",
			"\t\tif (GCD)",
			"\t\t{",
			"\t\t\tnumerator /= GCD;",
			"\t\t\tdenominator /= GCD;",
			"\t\t}",
			"\t\tif (denominator < 0)",
			"\t\t{",
			"\t\t\tnumerator *= -1;",
			"\t\t\tdenominator *= -1;",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tfraction<_Tp>& operator= (const fraction& _val)",
			"\t{",
			"\t\tnumerator = _val.numerator;",
			"\t\tdenominator = _val.denominator;",
			"\t\treturn *this;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfraction<_Tp>& operator= (const _OtherTp& _val)",
			"\t{",
			"\t\tnumerator = _val;",
			"\t\tdenominator = 1;",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tfraction<_Tp>& operator+= (const fraction& _val)",
			"\t{",
			"\t\tconst _Tp new_denominator = denominator / gcd(denominator, _val.denominator) * _val.denominator;",
			"\t\tnumerator = numerator * (new_denominator / denominator) + _val.numerator * (new_denominator / _val.denominator);",
			"\t\tdenominator = new_denominator;",
			"\t\tnormalize();",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\ttemplate <typename _OtherTp>",
			"\tfraction<_Tp>& operator+= (const _OtherTp& _val)",
			"\t{",
			"\t\tnumerator += _val * denominator;",
			"\t\tnormalize();",
			"\t\treturn *this;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfraction<_Tp> operator+ (const _OtherTp& _val)",
			"\t{",
			"\t\treturn fraction<_Tp>(*this) += _val;",
			"\t}",
			"",
			"\tfraction<_Tp>& operator-= (const fraction& _val)",
			"\t{",
			"\t\tconst _Tp new_denominator = denominator / gcd(denominator, _val.denominator) * _val.denominator;",
			"\t\tnumerator = numerator * (new_denominator / denominator) - _val.numerator * (new_denominator / _val.denominator);",
			"\t\tdenominator = new_denominator;",
			"\t\tnormalize();",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\ttemplate <typename _OtherTp>",
			"\tfraction<_Tp>& operator-= (const _OtherTp& _val)",
			"\t{",
			"\t\tnumerator -= _val * denominator;",
			"\t\tnormalize();",
			"\t\treturn *this;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfraction<_Tp> operator- (const _OtherTp& _val)",
			"\t{",
			"\t\treturn fraction<_Tp>(*this) -= _val;",
			"\t}",
			"",
			"\tfraction<_Tp>& operator*= (const fraction& _val)",
			"\t{",
			"\t\tnumerator *= _val.numerator;",
			"\t\tdenominator *= _val.denominator;",
			"\t\tnormalize();",
			"\t\treturn *this;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfraction<_Tp>& operator*= (const _OtherTp& _val)",
			"\t{",
			"\t\tnumerator *= _val;",
			"\t\tnormalize();",
			"\t\treturn *this;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfraction<_Tp> operator* (const _OtherTp& _val)",
			"\t{",
			"\t\treturn fraction<_Tp>(*this) *= _val;",
			"\t}",
			"",
			"\tfraction<_Tp>& operator/= (const fraction& _val)",
			"\t{",
			"\t\tnumerator *= _val.denominator;",
			"\t\tdenominator *= _val.numerator;",
			"\t\tnormalize();",
			"\t\treturn *this;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfraction<_Tp>& operator/= (const _OtherTp& _val)",
			"\t{",
			"\t\tdenominator *= _val;",
			"\t\tnormalize();",
			"\t\treturn *this;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfraction<_Tp> operator/ (const _OtherTp& _val)",
			"\t{",
			"\t\treturn fraction<_Tp>(*this) /= _val;",
			"\t}",
			"",
			"public:",
			"\ttemplate <typename _OtherTp>",
			"\tfriend _OtherTp& operator+= (_OtherTp& _other, const fraction& _val)",
			"\t{",
			"\t\treturn _other += _val.numerator / _val.denominator;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfriend _OtherTp operator+ (const _OtherTp& _other, const fraction& _val)",
			"\t{",
			"\t\treturn _other + _val.numerator / _val.denominator;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfriend _OtherTp& operator-= (_OtherTp& _other, const fraction& _val)",
			"\t{",
			"\t\treturn _other -= _val.numerator / _val.denominator;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfriend _OtherTp operator- (const _OtherTp& _other, const fraction& _val)",
			"\t{",
			"\t\treturn _other - _val.numerator / _val.denominator;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfriend _OtherTp& operator*= (_OtherTp& _other, const fraction& _val)",
			"\t{",
			"\t\treturn (_other *= _val.numerator) /= _val.denominator;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfriend _OtherTp operator* (const _OtherTp& _other, const fraction& _val)",
			"\t{",
			"\t\treturn _other * _val.numerator / _val.denominator;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfriend _OtherTp& operator/= (_OtherTp& _other, const fraction& _val)",
			"\t{",
			"\t\treturn (_other *= _val.denominator) /= _val.numerator;",
			"\t}",
			"",
			"\ttemplate <typename _OtherTp>",
			"\tfriend _OtherTp operator/ (const _OtherTp& _other, const fraction& _val)",
			"\t{",
			"\t\treturn _other * _val.denominator / _val.numerator;",
			"\t}",
			"",
			"\tfriend fraction sqrt(const fraction& _fraction)",
			"\t{",
			"\t\treturn fraction<_Tp>(sqrt(_fraction.numerator), sqrt(_fraction.denominator));",
			"\t}",
			"",
			"\tfriend fraction pow(const fraction& _fraction, const _Tp& _power)",
			"\t{",
			"\t\treturn fraction<_Tp>(pow(_fraction.numerator, _power), pow(_fraction.denominator, _power));",
			"\t}",
			"",
			"\tfriend istream& operator>> (istream& _is, fraction& _fraction)",
			"\t{",
			"\t\t_fraction.denominator = 1;",
			"\t\treturn _is >> _fraction.numerator;",
			"\t}",
			"",
			"\tfriend ostream& operator<< (ostream& _os, const fraction& _fraction)",
			"\t{",
			"\t\treturn _os << _fraction.numerator << '/' << _fraction.denominator;",
			"\t}",
			"",
			"public:",
			"\tfraction()",
			"\t\t: numerator(0), denominator(1)",
			"\t{",
			"\t}",
			"",
			"\tfraction(const _Tp& _numerator, const _Tp& _denominator)",
			"\t\t: numerator(_numerator), denominator(_denominator)",
			"\t{",
			"\t\tnormalize();",
			"\t}",
			"",
			"\tfraction(const fraction<_Tp>& _fraction)",
			"\t\t: numerator(_fraction.numerator), denominator(_fraction.denominator)",
			"\t{",
			"\t}",
			"};",
			"",
			"#endif /* _FRACTION */",
			"",
			"#pragma endregion"
		]
	},
